#pragma kernel CS_CountRays

#pragma only_renderers d3d11

RWTexture2D<uint4> _RayCountTexture;
// Interlocked add can only operate on scalar values,
// so allocate separate uint textures.
RWTexture2D<uint> _TotalAORaysTex;
RWTexture2D<uint> _TotalReflectionRaysTex;
RWTexture2D<uint> _TotalAreaShadowRaysTex;

groupshared uint aoRayCountPerThreadGroup;
groupshared uint reflectionRayCountPerThreadGroup;
groupshared uint areaShadowRayCountPerThreadGroup;

[numthreads(8,8,1)]
void CS_CountRays(uint3 globalId : SV_DispatchThreadID, uint3 localId : SV_GroupThreadID)
{
    // CS_CountRays reads from a texture holding ray count per pixel
    // and sums first across all pixels in a threadgroup,
    // and then across all threadgroups. Barriers are used to prevent contention.

    if (localId.x == 0 && localId.y == 0)
    {
        aoRayCountPerThreadGroup = 0;
        reflectionRayCountPerThreadGroup = 0;
        areaShadowRayCountPerThreadGroup = 0;
    }
		
    GroupMemoryBarrierWithGroupSync();
	
    const uint aoRayCount           = (uint)_RayCountTexture[globalId.xy].x;
    const uint reflectionRayCount   = (uint)_RayCountTexture[globalId.xy].y;
    const uint areaShadowRayCount   = (uint)_RayCountTexture[globalId.xy].z;
	
    InterlockedAdd(aoRayCountPerThreadGroup,            aoRayCount);
    InterlockedAdd(reflectionRayCountPerThreadGroup,    reflectionRayCount);
    InterlockedAdd(areaShadowRayCountPerThreadGroup,    areaShadowRayCount);
	
    GroupMemoryBarrierWithGroupSync();
		
    if (localId.x == 0 && localId.y == 0)
    {
        InterlockedAdd(_TotalAORaysTex[uint2(0, 0)].x, aoRayCountPerThreadGroup);
        InterlockedAdd(_TotalReflectionRaysTex[uint2(0, 0)].x, reflectionRayCountPerThreadGroup);
        InterlockedAdd(_TotalAreaShadowRaysTex[uint2(0, 0)].x, areaShadowRayCountPerThreadGroup);
    }
}